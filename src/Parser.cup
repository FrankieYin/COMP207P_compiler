import java_cup.runtime.*;
import java.util.*;

parser code {:

	boolean syntaxErrors = false;

	public void syntax_error(Symbol current_token) {
    report_error(
			"Syntax error at line " + (current_token.left+1) + ", column "
			+ current_token.right+"\n", null
			);
		syntaxErrors = true;
  }

:}

/* terminals */

/* non terminals */

/* precedence */

/* grammar */
start with goal;

goal ::=
		compilation_unit
	;
compilation_unit ::=
		type_declarations_opt main
	;
type_declarations_opt ::=
	| type_declarations_opt type_declaration
	;
type_declaration ::=
		variable_declaration
	| data_type_declaration
	| function_declaration
	| thread_declaration
	| type_aliasing
	;
thread_declaration ::=
		THREAD IDENTIFIER EQ LBRACE block RBRACE SEMI
	;
function_declaration ::=
		function_header LPAREN formal_param_list RPAREN LBRACE block_main RBRACE SEMI
	;
function_header ::=
		FDEF type_no_top identifier
	| FEDF identifier
	;
data_type_declaration ::=
		TDEF type_no_top LBRACE formal_param_list RBRACE SEMI
	;
formal_param_list ::=
	| formal_param_list COMMA formal_param_list
	| type_no_top identifier
	;
variable_declaration ::=
		variable_type identifier EQ expressions SEMI
	| variable_type identifier SEMI
	| dict_type  identifier EQ expressions SEMI
	| dict_type  identifier
	| seq_type identifier EQ expression SEMI
	| seq_type identifier SEMI
	| set_type identifier EQ expression SEMI
	| set_type identifier SEMI
	;
type_no_top ::=
		primitive_type
	| dict_type
	| seq_type
	| set_type
	| identifier
	| FUNCTION
	| THREAD
	;
primitive_type ::=
		CHAR
	| BOOL
	| INT
	| RAT
	| FLOAT
	;
type ::=
		type_no_top
	| TOP
	;
variable_type ::=
		primitive_type
	| identifier
	| FUNCTION
	;
dict_type ::=
		DICT LT type COMMA type GT
	;
seq_type ::=
		SEQ LT type GT
	;
set_type ::=
		SET LT type_no_top GT
	;
dict_literal ::=
		LPAREN dict_initialisers_opt RPAREN
	;
dict_initialisers_opt ::=
	| dict_initialisers_opt COMMA dict_initialiser
	;
dict_initialiser ::=
		expression COLON expression
	;
seq_literal ::=
		LBRACK expressions_opt RBRACK
	;
set_literal ::=
		LBRACE expressions_opt RBRACE
	;
expressions_opt ::=
	| expressions
	;
expressions ::=
		expression
	| expressions COMMA expression
	;
expression_opt ::=
	| expression
	;
expression ::=
		literals
	| dict_literal
	| seq_literal
	| set_literal
	| identifier
	| LPAREN expression RPAREN
	| expression operator expression
	| identifier LBRACK expression_opt COLON expression_opt RBRACK
	| function_call
	| identifier DOT LEN
	| MINUS expression %prec UMINUS
	| NOT expression
	| lambda_expression
	;
literals ::=
		STRING_LITERAL
	| CHAR_LITERAL
	| BOOL_LITERAL
	| INTEGER_LITERAL
	| RAT_LITERAL
	| FLOAT_LITERAL
	;
operator ::=
		conditional_operator
	| numeric_operator
	| relational_operator
	| set_operator
	| CONS
	;
conditional_operator ::=
		AND | OR
	;
numeric_operator ::=
		PLUS | MINUS
	| MULT | DIV
	| EXP
	;
relational_operator ::=
		LT | LTEQ | GT | GTEQ
	| EQEQ | NOTEQ
	| IN
	;
set_operator ::=
		VBAR | INTERSECTION | DIFF
	;
lambda_expression ::=
		lambda_header LBRACE block_only_statements RBRACE
	| lambda_header expression
	;
lambda_header ::=
		VBAR argument_list VBAR ARROW
	;
argument_list ::=
	| argument_list COMMA IDENTIFIER
	;

main ::=
		MAIN LBRACE block_main RBRACE
	;

block_only_statements ::=
		block_part_only_statements
	| block_only_statements block_part_only_statements
	;
block_part_only_statements ::=
		if_statement
	| while_statement
	| forall_statement
	| print_statement
	| read_statement
	| return_statement
	| assignment
	| function_call SEMI
	;
block ::=
	|	block block_part
	;
block_part ::=
		block_part_only_statements
	| variable_declaration
	| type_aliasing
	| thread_declaration
	;
block_main ::=
		block_part_main
	| block_main block_part_main
	;
block_part_main ::=
		block_part
	| function_declaration
	| data_type_declaration
	;
block_while ::=
		block_part_while
	| block_while block_part_while
	;
block_part_while ::=
		block_part
	| break_statement
	;

identifier ::=
		IDENTIFIER
	| identifier DOT IDENTIFIER
	| identifier LBRACK expression RBRACK
	;
assignment ::=
		identifier EQ expressions SEMI
	;
function_call ::=
		identifier LPAREN expressions_opt RPAREN
	|	LEN LPAREN identifier RPAREN
	| WAIT LPAREN IDENTIFIER RPAREN
	;
if_statement ::=
		IF LPAREN expression RPAREN THEN if_body FI
	;
if_body ::=
		block
	| block ELSE block
	| block ELIF LPAREN expression RPAREN THEN if_body
	;
if_statement_in_while ::=
		IF LPAREN expression RPAREN THEN if_body_in_while FI
	;
if_body_in_while ::=
		block_while
	| block_while ELSE block_while
	| block_while ELIF LPAREN expression RPAREN THEN if_body_in_while
	;
while_statement ::=
		WHILE LPAREN expression RPAREN DO block_while OD
	;
forall_statement ::=
		FORALL LPAREN IDENTIFIER IN expression RPAREN DO block OD
	;
forall_statement_in_while ::=
		FORALL LPAREN IDENTIFIER IN expression RPAREN DO block_while OD
	;
print_statement ::=
		PRINT expression_opt SEMI
	;
read_statement ::=
		READ identifier SEMI
	;
return_statement ::=
		RETURN expression_opt SEMI
	;
break_statement ::=
		BREAK expression_opt SEMI
	;













