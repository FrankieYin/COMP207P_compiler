// CUP specification for a normal expression evaluator (no actions)

import java_cup.runtime.*;

/* Preliminaries to set up and use the scanner.  */
init with {: scanner.init();              :};
scan with {: return scanner.next_token(); :};

parser code {:
	public boolean syntaxErrors = false;

	public void syntax_error(Symbol current_token) {
		report_error(
    	"Syntax error at line " + (current_token.left+1) + ", column "
				+ current_token.right, null);
		syntaxErrors = true;
	}
:};

/* Terminals */
terminal BOOLEAN;
terminal INT, CHAR;
terminal RAT, FLOAT;
terminal THREAD, FUNCTION, TOP, STRING;
terminal SEQ, SET, DICT;
terminal READ, PRINT;
terminal LBRACK, RBRACK, LBRACE, RBRACE, LPAREN, RPAREN;
terminal SEMI, COMMA, COLON, DOT;
terminal TDEF, FDEF, ALIAS;
terminal RETURN, BREAK;
terminal IF, FI, THEN, ELIF, ELSE;
terminal WHILE, DO, OD, FORALL;
terminal GT, LT, GTEQ, LTEQ, IN;
terminal ANDAND, OROR, EQEQ, NOTEQ, NOT;
terminal CONS;
terminal PLUS, MINUS, MULT, DIV, EXP;
terminal UPLUS, UMINUS;
terminal AND, OR, DIFF;
terminal RARROW;
terminal EQ;
terminal MAIN;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOAT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;

/* Non terminals */
non terminal goal;
non terminal literal;
non terminal type, primitive_type, container_type;
non terminal variable_type, set_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal name, normal_name, qualified_name;
non terminal compilation_unit;
non terminal type_declaration_opt, type_declarations, type_declaration;
non terminal main;
non terminal variable_declaration;
non terminal variable_declarators, variable_initialisers;
non terminal variable_declarator, variable_initialiser;
non terminal container_initialiser;
non terminal set_initialiser, seq_initialiser, dict_initialiser;
non terminal key_value_pairs, key_value_pair;
non terminal thread_declaration, thread_declarator;
non terminal data_type_declaration;
non terminal type_aliasing;
non terminal function_declaration;
non terminal normal_function_declaration;
non terminal function_header, function_body, function_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal lambda_function_declaration, lambda_expression;
non terminal lambda_parameters;
non terminal block;
non terminal block_statements_opt, block_statements;
non terminal block_statement, statement;
non terminal statement_without_trailing_substatement;
non terminal if_statement;
non terminal empty_statement, expression_statement, break_statement;
non terminal return_statement, print_statement, read_statement;
non terminal statement_expression;
non terminal assignment;
non terminal if_body;
non terminal statement_no_brace;
non terminal statement_no_brace_without_trailing_substatement;
non terminal block_no_brace, block_statements_no_brace_opt;
non terminal block_statements_no_brace, block_statement_no_brace;
non terminal elif_statements_opt;
non terminal elif_statements, elif_statement;
non terminal else_statement_opt, else_statement;
non terminal while_statement, forall_statement;
non terminal primary;
non terminal field_access, function_call;
non terminal argument_list_opt, argument_list;
non terminal container_access;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal exponetial_expression, multiplicative_expression;
non terminal additive_expression, set_expression;
non terminal cons_expression, relational_expression, in_expression;
non terminal equality_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal assignment_expression;
non terminal left_hand_side;
non terminal expression, expression_opt;

/* Precedences */
precedence left EQ;
precedence nonassoc RARROW;
precedence left OROR;
precedence left ANDAND;
precedence left EQEQ, NOTEQ;
precedence nonassoc LT, GT, LTEQ, GTEQ, IN;
precedence right CONS;
precedence left AND, OR, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence right EXP;
precedence right NOT, UMINUS, UPLUS;
precedence left DOT;

/* The grammar */
start with goal;

goal ::=
		compilation_unit
	;

/* literals */
literal ::=
		INTEGER_LITERAL
	| FLOAT_LITERAL
	| BOOLEAN_LITERAL
	| CHARACTER_LITERAL
	| STRING_LITERAL
	;

/* types */
type ::=
		primitive_type
	| container_type
	| STRING | TOP | THREAD | FUNCTION
	| IDENTIFIER // user defined types
	;
variable_type ::=
		primitive_type
	| container_type
	| STRING | TOP | FUNCTION
	| IDENTIFIER
	;
set_type ::=
		primitive_type
	| container_type
  | STRING | THREAD | FUNCTION
	| IDENTIFIER // user defined types
	;
primitive_type ::=
		BOOLEAN
	| numeric_type
	;
numeric_type ::=
		integral_type
	| floating_point_type
	;
integral_type ::=
		INT
	| CHAR
	;
floating_point_type ::=
		RAT
  | FLOAT
  ;
container_type ::=
		SET LT set_type GT
	| SEQ LT type GT
	| DICT LT type COMMA type GT
	;

/* names of variables */
name ::=
		normal_name
	| qualified_name
	;
normal_name ::=
		IDENTIFIER
	;
qualified_name ::=
		name DOT IDENTIFIER
	;

compilation_unit ::=
		type_declaration_opt main
	;
type_declaration_opt ::=
	| type_declarations
	;
type_declarations ::=
		type_declaration
	| type_declarations type_declaration
	;
type_declaration ::=
		variable_declaration
	| thread_declaration
	| data_type_declaration
	| type_aliasing
	| function_declaration
	;

/* variable declarations */
variable_declaration ::=
		variable_type variable_declarators SEMI
	;
variable_declarators ::=
		variable_declarator
	| variable_declarators COMMA variable_declarator
	;
variable_declarator ::=
		IDENTIFIER
	| IDENTIFIER EQ variable_initialiser
	;
variable_initialisers ::=
		variable_initialiser
	| variable_initialisers COMMA variable_initialiser
	;
variable_initialiser ::=
		expression
	| container_initialiser
	;
container_initialiser ::=
		set_initialiser
	| seq_initialiser
	| dict_initialiser
	;
set_initialiser ::=
		LBRACE variable_initialisers RBRACE
	| LBRACE RBRACE
	;
seq_initialiser ::=
		LBRACK variable_initialisers RBRACK
	| LBRACK RBRACK
	;
dict_initialiser ::=
		LPAREN key_value_pairs RPAREN
	| LPAREN RPAREN
	;
key_value_pairs ::=
		key_value_pair
	| key_value_pairs COMMA key_value_pair
	;
key_value_pair ::=
		variable_initialiser COLON variable_initialiser
	;

/* thread declarations */
thread_declaration ::=
		THREAD thread_declarator SEMI
	;
thread_declarator ::=
		IDENTIFIER EQ block
	;

/* data type declarations */
data_type_declaration ::=
		TDEF IDENTIFIER LBRACE formal_parameter_list RBRACE SEMI
	;

/* type aliasing */
type_aliasing ::=
		ALIAS type IDENTIFIER SEMI
	;

/* function declarations */
function_declaration ::=
		normal_function_declaration
	| lambda_function_declaration
	;
normal_function_declaration ::=
		function_header function_body SEMI
	;
function_header ::=
		FDEF type function_declarator
	| FDEF function_declarator
	;
function_declarator ::=
		IDENTIFIER LPAREN formal_parameter_list_opt RPAREN
	;
formal_parameter_list_opt ::=
	| formal_parameter_list
	;
formal_parameter_list ::=
		formal_parameter
	| formal_parameter_list COMMA formal_parameter
	;
formal_parameter ::=
		variable_type IDENTIFIER
	;
function_body ::=
		block
	;
lambda_function_declaration ::=
		FUNCTION IDENTIFIER EQ lambda_expression SEMI
	;
lambda_expression ::=
		OR lambda_parameters OR RARROW function_body
	| OR lambda_parameters OR RARROW expression
	;
lambda_parameters ::=
	|	IDENTIFIER
	| lambda_parameters COMMA IDENTIFIER
	;
main ::=
		MAIN function_body SEMI
	;

/* blocks and statements */
block ::=
		LBRACE block_statements_opt RBRACE
	;
block_statements_opt ::=
	| block_statements
	;
block_statements ::=
		block_statement
	| block_statements block_statement
	;
block_statement ::=
		statement
	| type_declaration
	;
statement ::=
		statement_without_trailing_substatement
	| if_statement
	| while_statement
	| forall_statement
	;
statement_without_trailing_substatement ::=
		block
	| empty_statement
	| expression_statement
	| break_statement
	| return_statement
	| print_statement
	| read_statement
	;
empty_statement ::=
		SEMI
	;
expression_statement ::=
		statement_expression SEMI
	;
statement_expression ::= // the expressions that will become a statement by appending SEMI
		assignment
	| function_call
	| cons_expression
	;

if_statement ::=
		IF LPAREN expression RPAREN THEN if_body FI
	;
if_body ::=
		statement_no_brace
		elif_statements_opt
		else_statement_opt
	;
statement_no_brace ::=
		statement_no_brace_without_trailing_substatement
	| if_statement
	| while_statement
	| forall_statement
	;
statement_no_brace_without_trailing_substatement ::=
		block_no_brace
	| empty_statement
	| expression_statement
	| break_statement
	| return_statement
	| print_statement
	| read_statement
	;
block_no_brace ::=
		block_statements_no_brace_opt
	;
block_statements_no_brace_opt ::=
	|	block_statements_no_brace
	;
block_statements_no_brace ::=
		block_statement_no_brace
	| block_statements_no_brace block_statement_no_brace
	;
block_statement_no_brace ::=
		statement_no_brace
	| type_declaration
	;
elif_statements_opt ::=
	| elif_statements
	;
elif_statements ::=
		elif_statement
	| elif_statements elif_statement
	;
elif_statement ::=
		ELIF LPAREN expression RPAREN THEN if_body
	;
else_statement_opt ::=
	|	else_statement
	;
else_statement ::=
		ELSE if_body
	;

while_statement ::=
		WHILE LPAREN expression RPAREN DO statement_no_brace OD
	;
forall_statement ::=
		FORALL LPAREN in_expression RPAREN DO statement_no_brace OD
	;
break_statement ::=
		BREAK expression_opt SEMI
	;
return_statement ::=
		RETURN expression_opt SEMI
	;
print_statement ::=
		PRINT expression_opt SEMI
	;
read_statement ::=
		READ name SEMI
	;

/* expressions */
primary ::=
		literal
	|	LPAREN expression RPAREN
	| field_access
	| function_call
	| container_access
	;
field_access ::=
		primary DOT IDENTIFIER
	| name DOT IDENTIFIER
	;
function_call ::=
		name LPAREN argument_list_opt RPAREN
	| primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN
	;
argument_list_opt ::=
	| argument_list
	;
argument_list ::=
		expression
	| argument_list COMMA expression
	;
container_access ::=
		name LBRACK expression RBRACK
	| primary LBRACK expression RBRACK
	;
unary_expression ::=
		PLUS unary_expression %prec UPLUS
	| MINUS unary_expression %prec UMINUS
	| unary_expression_not_plus_minus
	;
unary_expression_not_plus_minus ::=
		primary
	| name
	| NOT unary_expression
	;
exponetial_expression ::=
		unary_expression
	| exponetial_expression EXP unary_expression
	;
multiplicative_expression ::=
		exponetial_expression
	| multiplicative_expression MULT exponetial_expression
	| multiplicative_expression DIV exponetial_expression
	;
additive_expression ::=
		multiplicative_expression
	| additive_expression PLUS multiplicative_expression
	| additive_expression MINUS multiplicative_expression
	;
set_expression ::=
		additive_expression
	| set_expression AND additive_expression
	| set_expression OR additive_expression
	| set_expression DIFF additive_expression
	;
cons_expression ::=
		set_expression
	| cons_expression CONS set_expression
	;
relational_expression ::=
		cons_expression
	| relational_expression LT cons_expression
	| relational_expression GT cons_expression
	| relational_expression LTEQ cons_expression
	| relational_expression GTEQ cons_expression
	| relational_expression IN cons_expression
	;
in_expression ::=
		relational_expression IN cons_expression
	;
equality_expression ::=
		relational_expression
	| equality_expression EQEQ relational_expression
	| equality_expression NOTEQ relational_expression
	;
conditional_and_expression ::=
		equality_expression
	| conditional_and_expression ANDAND equality_expression
	;
conditional_or_expression ::=
		conditional_and_expression
	| conditional_or_expression OROR conditional_and_expression
	;
assignment_expression ::=
		conditional_or_expression
	| assignment
	;
assignment ::=
		left_hand_side EQ assignment_expression
	;
left_hand_side ::=
		name
	| field_access
	| container_access
	;
expression_opt ::=
	| expression
	;
expression ::=
		assignment_expression
	;
